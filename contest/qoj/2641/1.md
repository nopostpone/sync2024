[toc]

补题链接：

https://qoj.ac/contest/2641

个人代码放在：

https://github.com/nopostpone/xcpcTraining/tree/main/Regional/2025%20ICPC%20Shenyang

### A. Square Kingdom

首先有

$$
h_j - h_i = \frac{1}{a}(j - i)(ai + aj + 2b)
$$

答案一定是 $\frac 1a$ 的倍数，即分母为 $a$，我们来对分子 $x$ 二分答案。每次判断是否存在至少 $k$ 对 $(i, j)$ 满足 $(j - i)(ai + aj + 2b) \leq x$。

如果直接暴力，一次检查就是 $O(n^2)$，肯定是不允许的。我们来枚举因式的第一项 $j - i = d$，代入有

$$
d(ai + ai + ad + 2b) \leq x \\
i \leq \frac{x - 2bd - ad^2}{2ad}
$$

再有 $1 \leq i \leq n - d$，于是对于每个 $d$，我们能快速求得有多少个 $i$ 满足要求。现在每次检查的复杂度在于枚举 $d$ 的范围。

$d$ 的范围不会很大，因为对于 $(i, j)$，在 $[i, j]$ 中任选两点 $i' < j'$，都有 $h_{j'} - h_{i'} \leq h_j - h_i$。即如果一个 $d$ 中有一个 $i$ 满足，意味着已经至少存在 $\binom{d}{2}$ 个满足的数对了，$\binom d2 = \frac{d(d - 1)}2 \leq k$，得 $d$ 的上界在 $\sqrt{2k}$ 左右。

因此总复杂度 $O(\sqrt {k} \log V)$，$V$ 为值域，这里取 $6\times 10^{18}$。

### B. Buggy Painting Software I

有两个贪心策略：

- 如果要染色，一定在最上层染色。

- 如果钦定层数，从上至下，第 $i$ 层本身的颜色，一定设置为目标颜色中出现次数第 $i$ 多的。

枚举层数即可。设当前层数为 $x$，每增加一层，就需要令 $c_{nxt}x$ 个格子为无色，其中 $c_{nxt}$ 为下一层颜色的出现次数。

复杂度 $O\left(nm\log nm\right)$，瓶颈在排序。

### C. Buggy Painting Software II

每个串都独立地用一个非平凡二划分 $(S_0, S_1)$ 进行加密，因此我们要想办法：知道 $(S_0, S_1)$ 是什么并把串解密；试图建立二进制串到数字的唯一映射。

获取 $(S_0, S_1)$ 是比较显然的，我们在加密时，统一将前 $m$ 个位置都设置为 $1, 2, \dots, m$ 就行了。

如何建立数字到串的唯一映射呢？考虑循环移位。先想一个简单的，对于要加密的数 $x$，序列中间 $m$ 个位置，全部循环移位 $x$ 次。

这是一个映射，但在经过二进制加密后，并不能保证是一一映射的。例如当 $m = 4$ 时，有一个二进制划分的方式：

```
1 : [1 2 3 4] : [0 1 0 1]
3 : [3 4 1 2] : [0 1 0 1]
```

此时 $1$ 和 $3$ 就无法区分了。

这就相当于：长度为 $m$ 的任意非平凡（不是全 $0$ 或全 $1$）二进制串，循环左移若干位。什么情况下能由左移结果唯一确定左移量 $x$？

经过研究，可以发现是：当且仅当 $m$ 为质数时。下面给出证明。

若 $m$ 非质数，取它的一个真约数 $d$，构造周期为 $d$ 的二进制串，显然该串无法确定唯一的 $x$。因此，若要确定唯一的 $x$，$m$ 必须是质数。

接下来说明 $m$ 为质数时，一定能确定唯一的 $x$。

依然使用反证，不能确定唯一的 $x$，等价于有两个 $x$ 映射到了同一个串，记为 $v$。即在左移 $x_1$ 次后，还能左移 $x_1 - x_2 \bmod m$ 次，再次获得 $v$，这就意味着 $v$ 有一个周期。假设 $v$ 的最小周期为 $r$（$0 < r < m$），即对所有下标都有 $v_i = v_{i + kr \bmod m}$，其中 $k$ 为任意整数。

令 $d = \gcd(r, m)$，由裴属定理，存在整数 $u$ 和 $v$，满足 $ur + vm = d$，于是 $ur \equiv d \bmod m$。

又因为 $m$ 是质数，$d$ 在模 $m$ 的意义下一定是 $1$，因此 $ur \equiv 1 \bmod m$。回看关于周期的式子，代入得 $v_i = v_{i+kr\bmod m} = v_{i + 1 \bmod m}$，即 $r = 1$。也就是说这种情况下，$v$ 是全 $0$ 或全 $1$ 的串，这与非平凡二划分的定义矛盾。假设不成立。因此原命题得证。

由伯特兰-切比雪夫定理，在 $m$ 和 $2m$ 之间，一定存在一个质数。于是我们找到这个质数，把它当作要进行循环移位的段落的长度，就能够保证一定是唯一映射了。

实现上，加密是没有难度的。解密的问题可以抽象为：一个字符串 $s$ 循环移位若干次形成 $t$，求循环移位次数。这是一个经典问题，设 $s' = s + s$，寻找 $t$ 在 $s'$ 中第一次出现的位置即可。可以用 kmp 解决。复杂度 $O(nm)$。

### D. LED Display Renovation

比较难搞的 dp，学习了哥哥的做法，说一下大致思路。

一个数位只有 7 根灯管，一般可以用一个二进制数来表示一些信息。我们先处理出 `on[i]` 表示第 $i$ 个位置常亮的灯的集合，`off[i]` 表示第 $i$ 个位置常灭的集合；`num[x]` 表示显示数字 $x$ 时需要亮的灯的集合。

接着设 $f(i, j, 0/1)$ 表示考虑前 $i$ 个位置，翻新了 $j$ 根灯，且是否允许这 $i$ 个位置全空的情况下，能显示的最多数字；设 $g(i, j)$ 考虑前 $i$ 个位置，翻新了 $j$ 根灯，且**显示最多数字**的翻新方案数；设 $h(i, j)$ 为同样前提下的**所有**翻新方案数。

对于 $(i, j, e)$，遍历所有翻新方案的集合。对于一个翻新方案 $s$，从 $0$ 到 $9$ 统计出这种翻新方案下能合法显示的数字个数，记为 `cnt`；以及能合法显示且不作为前导零的数字个数，记为 `cntnz`。如何统计呢？对于数字 $x$，在它显示的时候，不能有灯管满足：

- 原先常亮、不翻新、且显示 $x$ 时是本应该暗的；
- 原先常暗、不翻新、且显示 $x$ 时是本应该亮的。

用二进制数表示集合，即需要 `(on[i] & ~s & ~num[x])` 和 `(off[i] & ~s & num[x])` 两者都为 $0$。

于是我们就得到了翻新之后能显示的数字个数，它由位置 $i$ 作为前面显示的数字的后缀（`f[i][j][e] * cnt`），和作为数字的第一位（`e * cntnz`）组成。如果个数大于 `f[i + 1][nj][ne]`，就将 $(i, j, e)$ 的所有状态覆盖给 $(i + 1, nj, ne)$；如果相等，就仅将 $(i, j, e)$ 的方案数加给 $(i + 1, nj, ne)$。

复杂度是 $O(2^N nk)$，其中 $N = 7$ 为一个数位的灯管数量。实现上细节很多，详见代码。

### F. The Bond Beyond Time

如果 $x$ 与 $y$ 不相邻，我们让 $x$ 与 $y$ 只能留在原地即可。

如果 $x$ 与 $y$ 相邻，且图是一棵树，那么一定存在一种方案使他们相遇。

下面来讨论 $x$ 与 $y$ 相邻，且图中有环的情况，此时是一定可以构造出永远不相遇的情形的。

先简化问题，如果整个图是一个环，则让他们顺时针跑就行。如果 $(x, y)$ 边在一个环上，且环中没有弦，那么同理，让他们只能顺着环跑就行，即把环的点标记出来，环上的边按照一个方向形成环。所有的 $(u, v)$ 边满足 $u$ 在环上，而 $v$ 不在环上，则令 $v$ 指向 $u$。

如果 $(x, y)$ 边不在环上呢？那就需要想办法让他们在不相遇的情况下走到一个环，然后再顺着环跑。不妨以 $x$ 为根，做一个图上的 dfs 生成树，选任意的非树边，标记与树边形成的环，这个环就是我们要走到的地方。

复杂度 $O(n^2)$ 或 $O(n + m)$。具体实现可以参考我的代码，这个思路并不难写。

### G. Collision Damage

$\bold t$ 怎么取，$P$ 和 $Q$ 会有交集呢？考虑一个向量 $\bold x \in P \cap (Q + \bold t)$ 的条件。我们将 $\bold x\in Q + \bold t$ 写成 $\bold x-\bold t\in Q$，如果设向量 $\bold y = \bold x - \bold t$，$\bold x$ 满足要求，意味着 $\bold x\in P$ 且 $\bold y\in Q$。则合法的 $\bold t = \bold x - \bold y$ 构成的集合为

$$
\{\bold x - \bold y ~|~ \bold x\in P, ~\bold y\in Q\}
$$

它即是 $P$ 和 $-Q$ 的闵可夫斯基和。

现在我们知道了合法的 $\bold t$ 的集合，设为 $D$。接下来考虑一个面元 $u \in P \cap (Q + \bold t)$ 的概率，根据之前的分析，不妨规定它首先要在 $P$ 内，选取 $D$ 中的每一个 $\bold t$，$u$ 落在 $Q+\bold t$ 的相对位置都是不同的，因此其落在 $Q+\bold t$ 内的概率为

$$
\frac {A(Q)}{A(D)}
$$

其中 $A(X)$ 表示多边形 $X$ 的面积。

由于期望的可加性，我们只需要看有多少个这样的面元 $u$ 即可，因为我们首先规定了 $u$ 在 $P$ 内，则有 $A(P)$ 个这样的 $u$，那么答案就是：

$$
\frac {A(P)A(Q)}{A(D)}=\frac {A(P)A(Q)}{A(P - Q)}
$$

复杂度 $O(n + m)$。

### I. Volunteer Simulator

模拟题意。

### J. The Echoes of Chronos

> 对下标的定义采用 0-indexed，左闭右开。

一个锻炼思维和实现能力的好题。

令 $x$ 在模 $m$ 意义下加一或减一，这个过程可以视作在一个长 $m$ 的环上顺时针或逆时针移动一个单位。于是我们可以将问题想象成，一个环上的若干点，要将他们扫到一起，需要走的最短路程，把这些点视作分割点，将环割成了若干段，答案就是环的长度减去最长的段。

于是，暴力的做法就出来了，对于每个询问 $(l, r, v)$，我们将 $a[l,r)$ 和 $v$ 放到环上，再统计最长段的长度，这样的复杂度是每个询问 $O(n)$ 的，于是尝试优化。

首先，我们不需要真的插入 $v$。可以仅在环上插入 $a[l, r)$，求出最长段和次长段，$v$ 如果不在最长段中，我们就取最长段，否则就取次长段，和最长段被割成的两段，这三段中的最长。因此我们在环上插入的点仅为 $a$ 中的元素。

进一步地，我们想将“在环上插入或移除点”的次数从 $O(nq)$ 降到可接受的范围，考虑将询问离线。下面来讲官方题解的做法。

我们做一个循环双向链表，需要支持可回滚的移除点操作，并维护最长段和次长段，初始时将 $a$ 中所有元素插入。

设一个块长 $B$，将所有询问 $(l, r, v)$ 以 $\lfloor \frac lB \rfloor$ 分块，同一块内以 $r$ 降序排序。维护一个 $pl$ 和 $pr$，代表目前环上的点来自 $a[pl, pr)$。初始时由于插入 $a$ 的所有元素，$pl = 0$，$pr = n$。

同一块内，对于询问 $(l, r, v)$，我们先将 $pl$ 移动到 $l$，删除 $a[pl, l)$，随后将 $pr$ 移动到 $r$，删除 $a[r, pr)$，然后求得该询问的答案。随后回滚 $pl$ 移动的过程——即将 $pl$ 再移动回原先的位置，并在链表上做相应的回滚。

做完一块的询问之后，先把 $pr$ 回滚到 $n$，然后将 $pl$ 永久往前移动 $B$，因为之后的询问中，不会再回到这一块中。

试分析复杂度。每个询问，$pl$ 移动的距离是 $O(B)$ 的；每一块的询问，$pr$ 移动的距离是 $O(n)$ 的，因此总复杂度为 $O(qB + \frac {n^2}{B})$，当 $B$ 取 $\sqrt n$ 时达到最小，为 $O((q + n)\sqrt n)$。

此题的实现方面是比较困难的，我的实现参考了一所诺亚老师，做了一些小改进。

### K. Relay Jump

在给定初始或终止条件，要求另一个，且中间的过程非常复杂时，我们可以寻找整个过程的不变量。

在此题中，设某一轮前每个青蛙坐标为 $P_i$，某一轮后每个青蛙坐标为 $P_i'$。青蛙 $i$ 跳过青蛙 $j$ 时，有

$$
P_i' + P_i = 2P_j
$$

又因为 $P_j=P_j'$，把上式写成

$$
\begin{align*}
P_j-P_i &= P_i'-P_j' \\
\sum_k P_k - 2P_i &= \sum_k P_k'- 2P_j'
\end{align*}
$$

即对于每一轮，$(\sum_k P_k - 2P_i)$ 是不变的，其中 $i$ 代表这一轮被激活的青蛙。现在告诉我们初始时的坐标和第一个跳的青蛙，于是这个不变量我们就能求出来，记为 $\Phi$。又告诉了我们最终所有青蛙的坐标，且两两不同，于是可以确定唯一的青蛙 $x$，满足 $(\sum_k Q_k - 2Q_x) = \Phi$，其中 $Q_i$ 代表最终 $i$ 的位置。

### L. Leo

直接看题解补了，比较趣味。

首先，由于 AND 操作会被 `*` 干扰，于是想办法在不影响第三种颜色的情况下把 `*` 消除。记原始信号序列为 $t$，我们从后往前，对于 $i < n$，做 $b_i := t_i ~OR~ t_{i + 1} ~OR~ t_{i + 1}$。若 $t_i$ 为 `*`，$a_i$ 就为 $t_{i + 1}$，否则为 $t_i$，那么 $a$ 中 `*` 只会出现为后缀，且其余颜色的出现顺序是不变的。

接下来先找第二个出现的颜色的位置，我们做 $a$ 的前缀与，令 $f_i = f_{i-1} ~AND~ a_i$，再令 $b_i = f_{i-1} ~OR~ a_i$。$f$ 的组成是：直到 $a$ 的第二个颜色之前，都与 $a$ 相同；在 $a$ 出现第二个颜色之后，为 `*`。而 $b$ 与 $a$ 仅在第二个颜色的位置处与 $a$ 不同，其余都与 $a$ 相同。

再求 $a_1 ~OR~ b_1 ~OR~ a_2 ~OR~ b_2 ~OR~ \dots ~OR~ a_n ~OR~ b_n$，结果即为答案。这是因为 $x ~OR~ y = -x - y \bmod 3$，上式的结果恰好就是 $a$ 和 $b$ 中唯一不同的那个位置在模 $3$ 意义下的差，唯一不同的那个位置 $k$，$a_k$ 为第二种颜色，而 $b_k$ 为第三种颜色，作差之后就是第三种颜色，即为所求。

### M. The End?

模拟题意。
